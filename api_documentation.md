# Bill Lens API Documentation

This documentation is designed for Android developers integrating with the Bill Lens Backend. The API is built to support an **Offline-First** architecture.

## Base URL
`http://<server-ip>:5000/expenses`

## Authentication

All endpoints require a Firebase ID Token in the Authorization header.

`Authorization: Bearer <firebase-id-token>`

## Data Models

### Expense Object
```json
{
  "id": "uuid-string",
  "userId": "firebase-uid", // Stored in DB, not always returned to client if redundant
  "totalAmount": 150.00, // Stored as Numeric(10, 2)
  "receiptDate": "2023-10-27T10:00:00",
  "category": "Food",
  "notes": "Lunch",
  "storeLocation": "123 Main St, New York",
  "insertionDate": "2023-10-27T10:05:00",
  "lastUpdated": "2023-10-27T10:05:00",
  "isDeleted": false
}
```

## Key Concepts for Offline-First

1.  **Client-Generated IDs (UUID)**:
    *   The Android app **MUST** generate a unique ID (UUID v4) when creating an expense locally.
    *   Do NOT wait for the server to assign an ID.
    *   Send this ID in the `POST` request.

2.  **Synchronization (Delta Sync)**:
    *   To get updates, use the `since` parameter.
    *   Store the `lastUpdated` timestamp of the most recent expense you have locally.
    *   When syncing, ask: `GET /expenses?since=<your-last-timestamp>`.
    *   The server returns only items changed (or deleted) after that time.

3.  **Soft Deletes**:
    *   When an item is deleted on the server, it is NOT removed from the database.
    *   It is marked as `isDeleted: true`.
    *   If you receive an item with `isDeleted: true` during sync, delete it from your local database.

## Endpoints

### 1. Create or Update Expense (Upsert)
**POST** `/expenses`

Used for both creating new expenses and syncing local edits to the server.

**Request Body**:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000", // REQUIRED: Generated by Client
  "totalAmount": 25.50,
  "receiptDate": "2023-10-27T14:30:00", // ISO 8601
  "category": "Transport",
  "notes": "Taxi to airport",
  "storeLocation": "Heathrow T5",
  "isDeleted": false // Optional, defaults to false
}
```

**Response (201 Created)**:
Returns the saved object.

### 2. Sync Expenses
**GET** `/expenses?since=<timestamp>`

Retrieves all expenses that have changed since the given timestamp.

**Parameters**:
*   `since` (Optional): ISO 8601 timestamp (e.g., `2023-10-26T00:00:00`).

**Response (200 OK)**:
List of `Expense` objects.
*   **Logic**:
    *   Iterate through the list.
    *   If `isDeleted` is `true` -> Delete from local DB.
    *   Else -> Insert or Update in local DB.

### 3. Delete Expense
**DELETE** `/expenses/<uuid>`

Marks an expense as deleted on the server.

**Response (200 OK)**:
```json
{
  "message": "Expense deleted",
  "id": "uuid-string"
}
```

### 4. Monthly Expenses
**GET** `/expenses/monthly/<year>/<month>`

Returns active expenses for a specific month.
*   Example: `/expenses/monthly/2023/10`

### 5. Analytics
**GET** `/expenses/analytics/last-month`

Returns the sum of expenses by category for the previous month.

**Response**:
```json
{
  "Food": 150.00,
  "Transport": 50.00
}
```

### 6. Export to Google Sheets
**POST** `/api/export/sheets`

Creates a Google Sheet with all active expenses.

**Request Body**:
```json
{
  "accessToken": "ya29.a0AfB_by..." // Optional: Access Token from Android for "User-Owned" export
}
```

**Response**:
```json
{
  "message": "Sheet created and shared successfully",
  "sheetUrl": "https://docs.google.com/spreadsheets/d/...",
  "sheetTitle": "Bill Lens Expenses - 2023-11-01 10:00",
  "sharedWith": "Owner (You)" // or email if using Service Account fallback
}
```

## Implementation Notes for Android

### Google Sheets Export (User-Owned)

To allow the user to own the exported file:
1.  **Scopes**: Request these scopes during Google Sign-In on Android:
    *   `https://www.googleapis.com/auth/drive.file`
    *   `https://www.googleapis.com/auth/spreadsheets`
2.  **Access Token**: Obtain the **Access Token** (not just ID Token) from the Google Sign-In account.
3.  **Send**: Pass this token in the `accessToken` field of the JSON body.
4.  **Fallback**: If you don't send the token, the server will try to use its Service Account (which has quota limits).

## Implementation Notes for Android

1.  **Authentication**:
    *   You **MUST** obtain a valid Firebase ID Token from the Firebase SDK on Android (`user.getIdToken(true)`).
    *   Include this token in the header of **EVERY** request: `Authorization: Bearer <token>`.
    *   The backend automatically extracts the `uid` from the token. You do NOT need to send `userId` in the JSON body or query parameters.

2.  **Performance**:
    *   The `user_id` field is indexed in the database. Queries filtering by user (which is all of them) are optimized.
    *   You don't need to do anything special on the client side for this optimization.

3.  **Data Isolation**:
    *   The API enforces strict data isolation. A user can NEVER access or modify another user's expenses, even if they guess a valid UUID, because the query always includes `WHERE user_id = <current_user>`.

## Connecting from Android (Real Device or Emulator)

### 1. Base URL
You cannot use `localhost` because that refers to the Android device itself.
*   **Emulator**: Use `http://10.0.2.2:5000/`
*   **Real Device**: Use your PC's local IP address (e.g., `http://192.168.1.15:5000/`).
    *   Find it by running `ipconfig` in your Windows terminal.
    *   Ensure your phone and PC are on the same Wi-Fi.

### 2. Retrofit Interface Example (Kotlin)

```kotlin
interface BillLensApi {
    @POST("expenses")
    suspend fun syncExpense(@Body expense: ExpenseDto): Response<ExpenseDto>

    @GET("expenses")
    suspend fun getExpenses(@Query("since") since: String?): Response<List<ExpenseDto>>

    @DELETE("expenses/{id}")
    suspend fun deleteExpense(@Path("id") id: String): Response<DeleteResponse>

    @GET("expenses/analytics/last-month")
    suspend fun getLastMonthAnalytics(): Response<Map<String, Double>>
}
```

### 3. Cleaning the Database
To remove all seed data and start fresh:
1.  Stop the server: `docker-compose down -v` (The `-v` flag deletes the database volume).
2.  Restart: `docker-compose up --build`.
3.  **Do NOT** run `seed.py`. The database will be empty and ready for your real data.
